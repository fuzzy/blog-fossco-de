#+AUTHOR: Mike 'Fuzzy' Partin
#+TITLE: A self-contained and portable home directory

* Synopsis

I have a *LOT* of machines in my home network. Some are your standard off-the-shelf PC types,
x86_64(amd64) stuff mainly, although I do have 2 i686 machines (eeePCs displaying monitoring
stats). I also have a [[https://uproxx.files.wordpress.com/2014/08/what-is-a-plethora.gif?w=650][plethora]] of ARM machines, both 32 and 64 bit (armv6/7 and aarch64[arm64]
respectively). I currently use a RockPro64 as my main desktop machine, but it fluctuates based on
stuff like, "what arm board am I playing with atm?" "is it a day that ends in 'y'?" "do I have
anything better to do?". You know, normal stuff. Anyhow, it's obvious that I'm only able to do this
and still get things done, one of two ways: 1) I get really good at or automate my local environment
setup (install anything I might need, check out my normal repos, setup configurations etc). or 2) I
have a portable setup that I can cart around either via some mechanism like NFS (or any shared
network filesystem) or an external drive.

* Goals

1. Create an external drive that contains the home directory setup
2. Ensure tools are installed in a os/arch agnostic manner
3. Ensure a consistent toolset across all os/arch combinations
4. Provide a backup and recovery mechanism

* Tools

1. POSIX sh (we'll be writing all of our automation to the lowest common denominator)
2. Git (gonna be needing this thing)
3. C/C++ Compiler toolchain and dev tools
4. rdiff-backup for incrimental backups
5. pxz or pbzip2 for compression of daily snapshots

* Getting started

First let's decide on a naming convention, and then let's take a look at designing the directory
structure. For my purposes I'm using the THWAP naming convention, as it's my general one. I'm not
going to go into the meaning behind that at this point, so don't ask. Suffice it to say, you can use
whatever convention you like. Now, as for the directory structure, I'm thining something along the
lines of the following:

#+BEGIN_EXAMPLE
- ~/.thwap
  - init.d
  - etc.d
  - scripts.d
  - pkg.d
  - library
      - OS_NAME (Ex: Linux)
        - ARCH_NAME (Ex: aarch64)
#+END_EXAMPLE

The first file we need to create would be our initialization, so we'll call that thwap.sh, and since
we already have an init.d directory, it seems we're well prepared for it. We'll use a naming
convention of <NNN>-<NAME>.sh for all of our other initialization files.

#+BEGIN_SRC sh
# Record the platform name
THWAP_OS=$(uname -s)
# and the architecture
THWAP_ARCH=$(uname -m)
# Set the base
THWAP_BASE=${HOME}/.thwap
# Our temp directory
THWAP_TEMP=${THWAP_HOME}/temp
# The home for our build scripts
THWAP_PKGD=${THWAP_BASE}/pkg.d
# Our configuration directory
THWAP_CONF=${THWAP_BASE}/etc.d
# And finally our install roots
THWAP_LIBR=${THWAP_BASE}/library
THWAP_HOME=${THWAP_LIBR}/${THWAP_OS}/${THWAP_ARCH}

# Quickly ensure all of our directories are present
for i in ${THWAP_BASE} ${THWAP_HOME} ${THWAP_LIBR} \
                       ${THWAP_TEMP} ${THWAP_PKGD}; do
    test ! -d ${i} && mkdir -p ${i}
done

# A quick utility function to add a directory to the $PATH environment
# variable if it is not already present
add2path() {
    if test -d ${1} && test -z "$(echo ${PATH}|grep ${1})"; then
        export PATH=${1}:${PATH}
    fi
}

# Before we start up with packages, let's ensure all of our initialization is finished
for itm in ${THWAP_BASE}/init.d/???-*.sh; do
    test -f ${itm} && . ${itm}
done

# Now we can ensure all of our packages are installed the way we want
for itm in ${THWAP_BASE}/pkg.d/*.sh; do
    test -f ${itm} && . ${itm}
done
#+END_SRC
